"use client";

import React, { useState, useEffect, useRef, useCallback } from "react";
import { FinanceEntry } from "@/lib/interfaces/finance-tracker.interface";
import toast, { Toaster } from "react-hot-toast";
import {
  PlusIcon,
  EditIcon,
  TrashIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
  CheckIcon,
  XIcon,
  WalletIcon,
} from "lucide-react";
import ConfirmDelete from "./components/ConfirmDelete";
import EditCategory from "./components/EditCategory";

const useIsMobile = () => {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkMobile = () => {
      // More comprehensive mobile detection
      const mobile =
        window.innerWidth < 768 ||
        /Mobi|Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        ) ||
        window.orientation !== undefined || // Check for orientation (typical on mobile)
        window.screen.width < 768; // Additional screen width check

      setIsMobile(mobile);
    };

    // Check on mount
    checkMobile();

    // Add event listener to check on resize
    window.addEventListener("resize", checkMobile);

    // Cleanup
    return () => window.removeEventListener("resize", checkMobile);
  }, []);

  return isMobile;
};

export default function FinanceTrackerPage() {
  const [entries, setEntries] = useState<FinanceEntry[]>([]);
  const [newEntry, setNewEntry] = useState<Partial<FinanceEntry>>({
    amount: 0,
    category: "",
    type: undefined, // Explicitly set to undefined, no default
    date: new Date(),
    description: "",
  });
  const [editingEntry, setEditingEntry] = useState<FinanceEntry | null>(null);
  const [categories, setCategories] = useState<string[]>([]);
  const [filteredCategories, setFilteredCategories] = useState<string[]>([]);
  const [isCategoryDropdownOpen, setIsCategoryDropdownOpen] = useState(false);
  const [categorySearchTerm, setCategorySearchTerm] = useState("");
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 5, // Default to 5 entries per page
    total: 0,
    totalPages: 0,
  });
  const [deleteConfirmation, setDeleteConfirmation] = useState<{
    type: "entry" | "category" | null;
    id?: string;
    name?: string;
  }>({
    type: null,
  });
  const [editingCategory, setEditingCategory] = useState<string | null>(null);
  const categorySearchInputRef = useRef<HTMLInputElement>(null);

  const isMobile = useIsMobile();

  useEffect(() => {
    // Set a default route secret if not already set
    if (!localStorage.getItem("ROUTE_SECRET")) {
      const defaultSecret = crypto.randomUUID();
      localStorage.setItem("ROUTE_SECRET", defaultSecret);
    }
  }, []);

  useEffect(() => {
    const storedCategories = localStorage.getItem("financeCategories");
    if (storedCategories) {
      setCategories(JSON.parse(storedCategories));
    }
  }, []);

  // Sort entries by newest timestamp
  const sortEntriesByNewestDate = (entries: FinanceEntry[]) => {
    return entries.sort((a, b) => {
      // Use the entry's ID (which is generated by Date.now()) as a timestamp
      // Add null checks and fallback to current timestamp if id is undefined
      const timestampA = a.id ? parseInt(a.id) : Date.now();
      const timestampB = b.id ? parseInt(b.id) : Date.now();
      return timestampB - timestampA;
    });
  };

  const fetchEntries = useCallback(async (page = 1) => {
    try {
      // Load entries from localStorage
      const allEntries = loadEntries();

      // Sort entries by timestamp (most recent first)
      const sortedEntries = sortEntriesByNewestDate(allEntries);

      // Calculate pagination
      const limit = 5; // Explicitly set to 5
      const startIndex = (page - 1) * limit;
      const endIndex = startIndex + limit;

      // Slice entries for the current page
      const paginatedEntries = sortedEntries.slice(startIndex, endIndex);

      // Update state
      setEntries(paginatedEntries);

      // Update pagination state
      setPagination({
        page,
        limit,
        total: allEntries.length,
        totalPages: Math.ceil(allEntries.length / limit),
      });
    } catch (error) {
      console.error("Error fetching entries:", error);
      toast.error("Failed to load entries", {
        position: "top-right",
        duration: 3000,
      });
    }
  }, []);

  useEffect(() => {
    fetchEntries();
  }, [fetchEntries]);

  useEffect(() => {
    // Update filtered categories when search term changes
    const filtered = categories.filter((category) =>
      category.toLowerCase().includes(categorySearchTerm.toLowerCase())
    );
    setFilteredCategories(filtered);
  }, [categories, categorySearchTerm]);

  useEffect(() => {
    if (
      isCategoryDropdownOpen &&
      categorySearchInputRef.current &&
      !editingEntry
    ) {
      categorySearchInputRef.current.focus();
    }
  }, [isCategoryDropdownOpen, editingEntry]);

  const loadEntries = () => {
    const storedEntries = localStorage.getItem("financeEntries");
    return storedEntries ? JSON.parse(storedEntries) : [];
  };

  const saveEntries = (updatedEntries: FinanceEntry[]) => {
    localStorage.setItem("financeEntries", JSON.stringify(updatedEntries));
    setEntries(updatedEntries);
  };

  const loadCategories = () => {
    const storedCategories = localStorage.getItem("financeCategories");
    const defaultCategories = [
      "Salary",
      "Groceries",
      "Rent",
      "Utilities",
      "Entertainment",
    ];

    if (!storedCategories) {
      // If no categories exist, set default categories
      localStorage.setItem(
        "financeCategories",
        JSON.stringify(defaultCategories)
      );
      setCategories(defaultCategories);
      return defaultCategories;
    }

    const parsedCategories = JSON.parse(storedCategories);
    setCategories(parsedCategories);
    return parsedCategories;
  };

  const saveCategories = (updatedCategories: string[]) => {
    localStorage.setItem(
      "financeCategories",
      JSON.stringify(updatedCategories)
    );
    setCategories(updatedCategories);
  };

  const selectCategory = useCallback((category: string) => {
    setNewEntry((prev) => ({
      ...prev,
      category: category,
    }));

    setIsCategoryDropdownOpen(false);
    setCategorySearchTerm(category);
  }, []);

  const createNewCategory = useCallback(
    (categoryName: string) => {
      const trimmedCategory = categoryName.trim();
      const formattedCategory =
        trimmedCategory.charAt(0).toUpperCase() + trimmedCategory.slice(1);

      // Check if category already exists (case-insensitive)
      if (
        categories.some(
          (cat) => cat.toLowerCase() === formattedCategory.toLowerCase()
        )
      ) {
        toast.error(`Category "${formattedCategory}" already exists`, {
          id: "duplicate-category",
          duration: 3000,
        });
        return;
      }

      // Add new category and update localStorage
      const updatedCategories = [...categories, formattedCategory];
      setCategories(updatedCategories);
      localStorage.setItem(
        "financeCategories",
        JSON.stringify(updatedCategories)
      );

      selectCategory(formattedCategory);

      // Show success toast
      toast.success(`Category "${formattedCategory}" created successfully`, {
        id: "category-created",
        duration: 3000,
      });
    },
    [categories, selectCategory]
  );

  const handleCategorySearch = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>) => {
      const searchTerm = e.target.value.trim();
      setCategorySearchTerm(searchTerm);
      setIsCategoryDropdownOpen(true);
    },
    []
  );

  const handleCategoryInputClick = useCallback(() => {
    setIsCategoryDropdownOpen(true);
    categorySearchInputRef.current?.focus();
  }, []);

  const handleEditCategory = useCallback((category: string) => {
    setEditingCategory(category);
    setCategorySearchTerm(category);

    // Use setTimeout to ensure the input is rendered before focusing
    setTimeout(() => {
      const inputElement = document.querySelector(
        `input[data-category="${category}"]`
      ) as HTMLInputElement;
      inputElement?.focus();
      inputElement?.select(); // Select all text for easy editing
    }, 0);
  }, []);

  const saveEditedCategory = useCallback(
    (oldCategory: string, newCategory: string) => {
      const trimmedCategory = newCategory.trim();

      // If no changes were made, just exit editing mode
      if (trimmedCategory === oldCategory) {
        setEditingCategory(null);
        setCategorySearchTerm("");
        return;
      }

      const formattedCategory =
        trimmedCategory.charAt(0).toUpperCase() + trimmedCategory.slice(1);

      // Check for duplicate categories
      if (
        categories.some(
          (cat) =>
            cat.toLowerCase() === formattedCategory.toLowerCase() &&
            cat !== oldCategory
        )
      ) {
        toast.error(`Category "${formattedCategory}" already exists`, {
          id: "duplicate-category",
          duration: 3000,
        });
        return;
      }

      // Update categories in state and localStorage
      const updatedCategories = categories.map((cat) =>
        cat === oldCategory ? formattedCategory : cat
      );

      setCategories(updatedCategories);
      localStorage.setItem(
        "financeCategories",
        JSON.stringify(updatedCategories)
      );

      // Save updated categories
      saveCategories(updatedCategories);

      // Show success toast
      toast.success(`Category renamed to "${newCategory}"`, {
        duration: 3000,
      });

      // Close modal
      setEditingCategory(null);
    },
    [categories]
  );

  const renderCategoryDropdown = useCallback(() => {
    const filtered = filteredCategories;

    return (
      <div className="absolute z-10 w-full mt-1 bg-white border border-gray-200 rounded-md shadow-sm max-h-60 overflow-auto">
        {filtered.length === 0 && categorySearchTerm.trim() ? (
          <div
            onClick={() => {
              const newCategory =
                categorySearchTerm.trim().charAt(0).toUpperCase() +
                categorySearchTerm.trim().slice(1);
              createNewCategory(newCategory);
            }}
            className="px-4 py-2 bg-blue-50 hover:bg-blue-100 cursor-pointer text-blue-600 font-medium transition-colors duration-150 ease-in-out flex items-center"
          >
            <PlusIcon className="h-4 w-4 mr-2 text-blue-500" />
            Create &quot;{categorySearchTerm.trim()}&quot;
          </div>
        ) : (
          filtered.map((category) => (
            <div
              key={category}
              className="group relative px-4 py-2 hover:bg-gray-100 flex justify-between items-center"
            >
              {editingCategory === category ? (
                <div className="flex items-center w-full space-x-2 bg-blue-50 p-1 rounded">
                  <input
                    type="text"
                    data-category={category}
                    value={categorySearchTerm}
                    onChange={(e) => setCategorySearchTerm(e.target.value)}
                    className="flex-grow border-b border-blue-300 bg-transparent px-2 py-1 focus:outline-none focus:border-blue-500"
                  />
                  <div className="flex items-center space-x-2">
                    <button
                      onClick={() =>
                        saveEditedCategory(category, categorySearchTerm)
                      }
                      className="text-green-600 hover:text-green-800 bg-green-100 hover:bg-green-200 p-1 rounded-full transition-colors"
                      title="Save"
                    >
                      <CheckIcon size={16} />
                    </button>
                    <button
                      onClick={() => {
                        setEditingCategory(null);
                        setCategorySearchTerm("");
                      }}
                      className="text-red-600 hover:text-red-800 bg-red-100 hover:bg-red-200 p-1 rounded-full transition-colors"
                      title="Cancel"
                    >
                      <XIcon size={16} />
                    </button>
                  </div>
                </div>
              ) : (
                <div className="flex items-center justify-between w-full">
                  <span
                    onClick={() => selectCategory(category)}
                    className="cursor-pointer text-gray-600 hover:text-gray-800 flex-grow"
                  >
                    {category}
                  </span>

                  <div className="flex items-center space-x-2 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                    <EditIcon
                      className="h-4 w-4 text-gray-500 hover:text-blue-500 cursor-pointer"
                      onClick={(e) => {
                        e.stopPropagation();
                        handleEditCategory(category);
                      }}
                    />
                    <TrashIcon
                      className="h-4 w-4 text-gray-500 hover:text-red-500 cursor-pointer"
                      onClick={() =>
                        setDeleteConfirmation({
                          type: "category",
                          name: category,
                        })
                      }
                    />
                  </div>
                </div>
              )}
            </div>
          ))
        )}
      </div>
    );
  }, [
    filteredCategories,
    categorySearchTerm,
    selectCategory,
    createNewCategory,
    editingCategory,
    handleEditCategory,
    saveEditedCategory,
    setDeleteConfirmation,
  ]);

  const handleAddEntry = (event?: React.FormEvent) => {
    // Prevent default form submission if event is provided
    if (event) {
      event.preventDefault();
    }

    // Validate required fields
    if (
      !newEntry.category ||
      !newEntry.amount ||
      !newEntry.date ||
      !newEntry.type
    ) {
      toast.error("Please fill in all required fields, including entry type", {
        position: isMobile ? "top-center" : "top-right",
        duration: 3000,
      });
      return;
    }

    // Prepare entry data
    const entryToSave: FinanceEntry = {
      ...newEntry,
      id: editingEntry?.id || Date.now().toString(), // Use existing ID or generate new
      amount: parseFloat(newEntry.amount.toString()),
      category: newEntry.category || "", // Ensure category is a non-optional string
      type: newEntry.type, // Remove default "income"
      date: newEntry.date || new Date(), // Ensure date is non-optional
    };

    // Load existing entries
    const existingEntries = loadEntries();

    // Add entry to existing entries
    const updatedEntries = editingEntry
      ? existingEntries.map((entry: FinanceEntry) =>
          entry.id === editingEntry.id ? entryToSave : entry
        )
      : [...existingEntries, entryToSave];

    // Sort entries by timestamp (most recent first)
    const sortedEntries = sortEntriesByNewestDate(updatedEntries);
    setEntries(sortedEntries);
    saveEntries(sortedEntries);

    // Clear input fields and reset state
    setNewEntry({
      amount: 0,
      category: "",
      type: undefined,
      date: new Date().toISOString().split("T")[0],
      description: "",
    });

    // Reset editing state
    setEditingEntry(null);

    // Close category dropdown if open
    setIsCategoryDropdownOpen(false);

    // Clear category search term
    setCategorySearchTerm("");

    // Success toast
    toast.success(
      editingEntry
        ? "Entry updated successfully!"
        : "Entry added successfully!",
      {
        position: isMobile ? "top-center" : "top-right",
        duration: 3000,
      }
    );

    // Dynamically update pagination
    const limit = 5;
    const currentPage = pagination.page;
    const totalPages = Math.ceil(updatedEntries.length / limit);

    // Determine if we need to adjust the current page
    const adjustedPage = currentPage > totalPages ? totalPages : currentPage;

    // Slice entries for the current page
    const startIndex = (adjustedPage - 1) * limit;
    const endIndex = startIndex + limit;
    const paginatedEntries = updatedEntries.slice(startIndex, endIndex);

    // Update state
    setEntries(paginatedEntries);
    setPagination({
      page: adjustedPage,
      limit,
      total: updatedEntries.length,
      totalPages,
    });
  };

  const handleEdit = (entry: FinanceEntry) => {
    // Set the entry to edit
    setEditingEntry(entry);

    // Set the new entry with the current entry's details
    setNewEntry({
      id: entry.id,
      amount: entry.amount,
      category: entry.category,
      type: entry.type,
      date: new Date(entry.date),
      description: entry.description || "",
    });

    // Set category search term to the current category
    setCategorySearchTerm(entry.category);

    // Ensure categories are fetched (in case they weren't)
    if (categories.length === 0) {
      loadCategories();
    }

    // Optional: Open category dropdown to show available options
    setIsCategoryDropdownOpen(true);

    // Scroll to the top of the form
    window.scrollTo({ top: 0, behavior: "smooth" });
  };

  const handleDelete = (id: string) => {
    const updatedEntries = entries.filter((entry) => entry.id !== id);
    const sortedEntries = sortEntriesByNewestDate(updatedEntries);
    setEntries(sortedEntries);
    saveEntries(sortedEntries);

    // Add success toast
    toast.success("Entry deleted successfully!", {
      position: isMobile ? "top-center" : "top-right",
      duration: 3000,
    });
  };

  const handleDeleteConfirmation = () => {
    if (deleteConfirmation.type === "entry" && deleteConfirmation.id) {
      handleDelete(deleteConfirmation.id);
    } else if (
      deleteConfirmation.type === "category" &&
      deleteConfirmation.name
    ) {
      deleteCategory(deleteConfirmation.name);
    }

    // Reset delete confirmation
    setDeleteConfirmation({ type: null });
  };

  const cancelEdit = () => {
    // Reset new entry state to default
    setNewEntry({
      amount: 0,
      category: "",
      type: undefined,
      date: new Date().toISOString().split("T")[0],
      description: "",
    });

    // Reset editing state
    setEditingEntry(null);

    // Close category dropdown if open
    setIsCategoryDropdownOpen(false);
  };

  const deleteCategory = (categoryToDelete: string) => {
    try {
      // Get current categories
      const currentCategories = loadCategories();

      // Remove the category
      const updatedCategories = currentCategories.filter(
        (cat: string) => cat !== categoryToDelete
      );

      // Save updated categories
      saveCategories(updatedCategories);

      // Reset category in newEntry if it matches the deleted category
      if (newEntry.category === categoryToDelete) {
        setNewEntry((prev) => ({
          ...prev,
          category: "", // Clear the category
        }));
      }

      // Reset category search and dropdown
      setCategorySearchTerm("");
      setIsCategoryDropdownOpen(false);

      // Success toast
      toast.success(`Category "${categoryToDelete}" deleted successfully`, {
        position: isMobile ? "top-center" : "top-right",
        duration: 3000,
      });
    } catch (error) {
      console.error("Error deleting category:", error);
      toast.error(`Failed to delete category "${categoryToDelete}"`, {
        position: isMobile ? "top-center" : "top-right",
        duration: 3000,
      });
    }
  };

  const handlePageChange = (newPage: number) => {
    if (newPage > 0 && newPage <= pagination.totalPages) {
      fetchEntries(newPage);
    }
  };

  const renderPagination = () => {
    const { page, totalPages } = pagination;

    if (totalPages <= 1) return null;

    return (
      <div className="flex justify-center items-center space-x-2 mt-6">
        <button
          onClick={() => handlePageChange(page - 1)}
          disabled={page === 1}
          className="p-2 rounded-lg hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
        >
          <ChevronLeftIcon size={20} className="text-gray-600" />
        </button>

        {[...Array(totalPages)].map((_, index) => {
          const pageNumber = index + 1;
          return (
            <button
              key={pageNumber}
              onClick={() => handlePageChange(pageNumber)}
              className={`
                w-8 h-8 rounded-lg 
                ${
                  page === pageNumber
                    ? "bg-blue-500 text-white"
                    : "text-gray-600 hover:bg-gray-100"
                }
                transition-colors
              `}
            >
              {pageNumber}
            </button>
          );
        })}

        <button
          onClick={() => handlePageChange(page + 1)}
          disabled={page === totalPages}
          className="p-2 rounded-lg hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
        >
          <ChevronRightIcon size={20} className="text-gray-600" />
        </button>
      </div>
    );
  };

  const renderToaster = () => {
    return (
      <Toaster
        position={isMobile ? "top-center" : "top-right"}
        toastOptions={{
          duration: 3000,
          style: {
            maxWidth: 400,
            padding: "12px 20px",
            background: "#f0f0f0",
            color: "#333",
            boxShadow: "0 4px 6px rgba(0,0,0,0.1)",
            border: "1px solid #e0e0e0",
          },
        }}
      />
    );
  };

  return (
    <div className="min-h-screen bg-gray-50 p-4 sm:p-6 lg:p-8">
      <div className="max-w-4xl mx-auto bg-white shadow-xl rounded-xl overflow-hidden">
        <div className="p-6 bg-gradient-to-r from-blue-500 to-purple-600">
          <h1 className="text-2xl font-bold text-white text-center">
            {editingEntry ? "Edit Entry" : "Finance Tracker"}
          </h1>
        </div>

        <div className="p-6">
          <form onSubmit={(e) => handleAddEntry(e)} className="space-y-4">
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              <div className="relative">
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Amount
                </label>
                <div className="relative">
                  <span className="absolute inset-y-0 left-0 pl-3 flex items-center text-gray-500">
                    $
                  </span>
                  <input
                    type="number"
                    placeholder="0.00"
                    value={newEntry.amount || ""} // Use empty string when 0
                    onChange={(e) => {
                      const inputValue =
                        e.target.value === "" ? 0 : Number(e.target.value);
                      setNewEntry({ ...newEntry, amount: inputValue });
                    }}
                    className="w-full pl-7 pr-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-gray-500"
                    min="0"
                    step="0.01"
                  />
                </div>
              </div>

              <div className="mb-4">
                <label
                  htmlFor="category"
                  className="block text-sm font-medium text-gray-700 mb-1"
                >
                  Category
                </label>
                <div
                  onClick={() =>
                    setIsCategoryDropdownOpen(!isCategoryDropdownOpen)
                  }
                  className="w-full relative"
                >
                  <input
                    ref={categorySearchInputRef}
                    type="text"
                    id="category"
                    value={categorySearchTerm}
                    onClick={handleCategoryInputClick}
                    onChange={handleCategorySearch}
                    placeholder="Search or create category"
                    className="w-full p-2 border border-gray-300 rounded text-gray-500"
                  />
                  <div className="absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none">
                    <svg
                      className="h-5 w-5 text-gray-400"
                      fill="currentColor"
                      viewBox="0 0 20 20"
                    >
                      <path
                        fillRule="evenodd"
                        d="M10 3a1 1 0 01.707.293l3 3a1 1 0 01-1.414 1.414L10 5.414 7.707 7.707a1 1 0 01-1.414-1.414l3-3A1 1 0 0110 3zm-3.707 9.293a1 1 0 011.414 0L10 14.586l2.293-2.293a1 1 0 011.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z"
                        clipRule="evenodd"
                      />
                    </svg>
                  </div>

                  {isCategoryDropdownOpen && renderCategoryDropdown()}
                </div>
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Type
                </label>
                <select
                  value={newEntry.type ?? ""}
                  onChange={(e) =>
                    setNewEntry({
                      ...newEntry,
                      type:
                        e.target.value === ""
                          ? undefined
                          : (e.target.value as "income" | "expense"),
                    })
                  }
                  className="w-full px-2 py-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-gray-500 bg-white"
                >
                  <option value="">Select type</option>
                  <option value="expense">Expense</option>
                  <option value="income">Income</option>
                </select>
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Date
                </label>
                <input
                  type="date"
                  value={
                    newEntry.date
                      ? new Date(newEntry.date).toISOString().split("T")[0]
                      : ""
                  }
                  onChange={(e) =>
                    setNewEntry({ ...newEntry, date: new Date(e.target.value) })
                  }
                  className="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-gray-500"
                  required
                />
              </div>

              <div className="col-span-full">
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Description (Optional)
                </label>
                <textarea
                  placeholder="Add a description for this entry"
                  value={newEntry.description || ""}
                  onChange={(e) =>
                    setNewEntry({ ...newEntry, description: e.target.value })
                  }
                  className="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-gray-500"
                  rows={3}
                  maxLength={500}
                />
              </div>
            </div>

            <div className="flex space-x-4">
              <button
                type="submit"
                className="flex-1 bg-gradient-to-r from-blue-500 to-purple-600 text-white py-3 rounded-md hover:opacity-90 transition-opacity"
              >
                {editingEntry ? "Update Entry" : "Add Entry"}
              </button>
              {editingEntry && (
                <button
                  type="button"
                  onClick={cancelEdit}
                  className="flex-1 bg-gray-200 text-gray-800 py-3 rounded-md hover:bg-gray-300 transition-colors"
                >
                  Cancel
                </button>
              )}
            </div>
          </form>

          <div className="mt-8">
            <h2 className="text-xl font-semibold mb-4 text-gray-800">
              Recent Entries
            </h2>
            <div className="overflow-x-auto">
              <table className="w-full bg-white shadow rounded-lg overflow-hidden">
                <thead className="bg-gray-100">
                  <tr>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Amount
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Category
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Type
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Date
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Description
                    </th>
                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                      Actions
                    </th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-gray-200">
                  {entries.length === 0 && (
                    <tr>
                      <td colSpan={6} className="text-center py-4">
                        <div className="flex flex-col items-center justify-center">
                          <WalletIcon className="w-12 h-12 text-gray-400 mb-4" />
                          <p className="text-sm text-gray-600">
                            No finance entries yet. Start tracking your income
                            and expenses.
                          </p>
                        </div>
                      </td>
                    </tr>
                  )}
                  {entries.map((entry) => (
                    <tr
                      key={entry.id || crypto.randomUUID()}
                      className="hover:bg-blue-50 transition-colors"
                    >
                      <td
                        className={`px-4 py-4 whitespace-nowrap max-w-[150px] overflow-hidden text-ellipsis ${
                          entry.type === "income"
                            ? "text-green-600"
                            : "text-red-600"
                        }`}
                      >
                        {entry.amount !== undefined && entry.amount !== null
                          ? `$${entry.amount.toFixed(2)}`
                          : "N/A"}
                      </td>
                      <td className="px-4 py-4 whitespace-nowrap max-w-[150px] overflow-hidden text-ellipsis text-gray-900">
                        {entry.category}
                      </td>
                      <td className="px-4 py-4 whitespace-nowrap">
                        <span
                          className={`px-2 py-1 rounded-full text-xs font-medium ${
                            entry.type === "income"
                              ? "bg-green-100 text-green-800"
                              : "bg-red-100 text-red-800"
                          }`}
                        >
                          {entry.type}
                        </span>
                      </td>
                      <td className="px-4 py-4 whitespace-nowrap text-gray-500">
                        {new Date(entry.date).toLocaleDateString()}
                      </td>
                      <td className="px-4 py-4 text-gray-600 truncate max-w-xs">
                        {entry.description || "-"}
                      </td>
                      <td className="px-4 py-4 whitespace-nowrap">
                        <div className="flex space-x-2">
                          <button
                            onClick={() => handleEdit(entry)}
                            className="text-blue-600 hover:text-blue-800 transition-colors"
                            title="Edit"
                          >
                            <EditIcon size={20} />
                          </button>
                          <button
                            onClick={() =>
                              setDeleteConfirmation({
                                type: "entry",
                                id: entry.id,
                              })
                            }
                            className="text-red-600 hover:text-red-800 transition-colors"
                            title="Delete"
                          >
                            <TrashIcon size={20} />
                          </button>
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
            {renderPagination()}
          </div>
        </div>
      </div>
      {renderToaster()}
      {deleteConfirmation.type && (
        <ConfirmDelete
          type={deleteConfirmation.type}
          name={deleteConfirmation.name}
          onConfirm={handleDeleteConfirmation}
          onCancel={() => setDeleteConfirmation({ type: null })}
        />
      )}

      {/* Render EditCategory modal */}
      {editingCategory && (
        <EditCategory
          category={editingCategory}
          onSave={(newCategory) => {
            // Check for duplicate category
            if (
              categories.some(
                (cat) =>
                  cat.toLowerCase() === newCategory.toLowerCase() &&
                  cat !== editingCategory
              )
            ) {
              toast.error(`Category "${newCategory}" already exists`, {
                duration: 3000,
              });
              return;
            }

            // Update categories
            const updatedCategories = categories.map((cat) =>
              cat === editingCategory ? newCategory : cat
            );

            // Save updated categories
            saveCategories(updatedCategories);

            // Show success toast
            toast.success(`Category renamed to "${newCategory}"`, {
              duration: 3000,
            });

            // Close modal
            setEditingCategory(null);
          }}
          onCancel={() => setEditingCategory(null)}
        />
      )}
    </div>
  );
}
